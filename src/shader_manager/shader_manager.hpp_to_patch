#include <string>
#include <vector>
#include <stack>
#include <array>

#include <cstring>

#include <GLFW/glfw3.h>

using GL_ID = unsigned int;

//TODO: Create a generic glObject class
// Templated by the type of what we create exactly
// (Vertex_Shader, Fragment_Shader, Shader_Program,...)
// All of the classes below inherit from it in different ways
// Allows us a common interface to operate on glObject's
// (For example for getting the error message of an operation)
// Does it have a generic do_action<T> method ?

class Abstract_Shader
{
    public:

        Abstract_Shader (GL_ID shader, const std::string& code)
        : _shader(shader), _code(code)
        {
        }

        GL_ID get_shader_id() const { return _shader;} 
        void set_code(const std::string& code) { _code = code;}

        int compile() const
        {
            int success;

            const char* data = _code.data();
            glShaderSource(_shader, 1, &data, NULL);

            glCompileShader(_shader);
            glGetShaderiv(_shader, GL_COMPILE_STATUS, &success);
            return success;
        }

        std::string get_compile_error() const
        {
            std::string log(512, ' ');
            glGetShaderInfoLog(_shader, log.length(), NULL, &log[0]);
            return log;
        }

        //TODO: Where do we put detach() ?
        ~Abstract_Shader()
        {
            //TODO: Deletion of a shader can fail, we need to get the error
            //message with glGetProgramiv.
            glDeleteShader(_shader);
        }
    private:
        const GL_ID _shader;
        std::string _code;
};

template <typename T>
concept Floating_Point = std::is_floating_point_v<T>;

template <Floating_Point F = float,
          size_t _Dimensions = 3>
class Point
{
    using Container = std::array<F, _Dimensions>;
    public:
        constexpr Point(const Container& coordinates)
            : _coordinates(coordinates)
        {}

        constexpr Point(const F& x, const F& y, const F& z)
            : _coordinates({x, y , z})
        {}
    static const size_t Dimensions = _Dimensions;
    private:
        const Container _coordinates;
};

template <size_t _Sides, typename P = Point<float, 3>>
class Shape
{
    using Container = std::array<P, _Sides>;
    public:
        template <typename ...Arg,
                //We limit the number of arguments the constructor of Shape can take.
                std::enable_if_t<(sizeof...(Arg) == _Sides)>* = nullptr>
        Shape(Arg&& ...arguments)
            : points({std::move(arguments)...})
        {
        }
        
    static const size_t Nb_Of_Sides = _Sides; 
    private:

        const Container points;
};

template <Floating_Point f>
struct GL_ENUM
{
    static const GLenum value;
};

template <>
struct GL_ENUM<float>
{
    static const GLenum value = GL_FLOAT;
};

template <>
struct GL_ENUM<double>
{
    static const GLenum value = GL_DOUBLE;
};

//TODO: Template by a type of shape.
template <Floating_Point f = float>
class Vertex_Shader : public Abstract_Shader
{
    using Container = std::vector<f>;
    public:
        Vertex_Shader(const Container &vertices, const std::string& code)
            : Abstract_Shader(glCreateShader(GL_VERTEX_SHADER), code)
        {
            _vertices = vertices;
            glGenVertexArrays(1, &VAO);
            glGenBuffers(1, &VBO);

            glBindVertexArray(VAO);

            int buffer_size = vertices.size() * sizeof(f);
            // This will copy the data into the currently bound buffer, so in
            // our case, VBO.
            glBindBuffer(GL_ARRAY_BUFFER, VBO);
            glBufferData(GL_ARRAY_BUFFER, buffer_size, _vertices.data(), GL_STATIC_DRAW);

            int vertex_stride = 3 * sizeof(f); //TODO: Replace 3 by Shape::Dimensions
            int components_nb = 3; //TODO: Shape::Sides
            glVertexAttribPointer(0, components_nb, GL_ENUM<f>::value, GL_FALSE, vertex_stride, nullptr);
            glEnableVertexAttribArray(0);

            glBindBuffer(GL_ARRAY_BUFFER, 0);
            glBindVertexArray(0);
        }

        GL_ID get_VAO() const {return VAO;}
    private:
        /* TODO: Do we want to create another GL_ID class that we could
         * constify here and that would itself call glGen*() ?
         */
        GL_ID VBO;
        GL_ID VAO;

        Container _vertices;
};

class Fragment_Shader : public Abstract_Shader
{
    public:
        Fragment_Shader(const std::string &code)
            : Abstract_Shader(glCreateShader(GL_FRAGMENT_SHADER), code)
        {}
};

class Program_Shader
{
    public:
        Program_Shader()
        {
            prog = glCreateProgram();
        }

        void attach_shader(const Abstract_Shader &shader)
        {
            glAttachShader(prog, shader.get_shader_id());
        }

        void detach_shader(const Abstract_Shader &shader)
        {
            glDetachShader(prog, shader.get_shader_id());
        }

        void set_VAO(const Vertex_Shader<float> &shader)
        {
            VAO = shader.get_VAO();
        }

        void use()
        {
            glUseProgram(prog);
        }

        void draw()
        {
            glBindVertexArray(VAO);
            glDrawArrays(GL_TRIANGLES, 0, 3);
        }

        int link()
        {
            int success;
            glLinkProgram(prog);
            glGetProgramiv(prog, GL_LINK_STATUS, &success);
            return success;
        }

        std::string get_link_error()
        {
            std::string log(512, ' ');
            glGetShaderInfoLog(prog, log.length(), NULL, &log[0]);
            return log;
        }
    private:
        GL_ID prog;
        GL_ID VAO;
};

@@SHADERS@@
