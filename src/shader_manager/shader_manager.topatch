#include <string>
#include <vector>

#include <cstring>

#include <GLFW/glfw3.h>
    /* 
     * We want to statically embed all shaders in the `shaders` directory.
     * We can only embed the code of the shader and not the shader object
     * itself. The shader object compilation can be affected by a myriad of
     * things and its really not a good idea to try to be smart about it.
     * The only `optimization` we do is precompile all shaders at startup.

     * We probably need to use `xxd` to extract text from the files.
     * We also probably need some tomfoolery to patch the shader manager.
     * We can do it in cmake or in python (I'd prefer this approach as it has more
     * chances of being portable ?)
     */



using GL_ID = unsigned int;

class Abstract_Shader
{
    public:

        Abstract_Shader (GL_ID shader, const std::string& code)
        : _shader(shader), _code(code)
        {
        }

        GL_ID get_shader_id() const { return _shader;} 
        void set_code(const std::string& code) { _code = code;}

        int compile_shader() const
        {
            int success;

            const char* data = _code.data();
            glShaderSource(_shader, 1, &data, NULL);

            glCompileShader(_shader);
            glGetShaderiv(_shader, GL_COMPILE_STATUS, &success);
            return success;
        }

        std::string get_compile_error() const
        {
            std::string log(512, ' ');
            glGetShaderInfoLog(_shader, log.length(), NULL, &log[0]);
            return log;
        }

    private:
        const GL_ID _shader;
        std::string _code;
};

template <typename Float = float,
      typename Container = std::vector<Float>>
class Vertex_Shader : public Abstract_Shader
{
    public:
        Vertex_Shader(const Container &vertices, const std::string& code)
            : Abstract_Shader(glCreateShader(GL_VERTEX_SHADER), code)
        {
            this->vertices = vertices;
            glGenBuffers(1, &VBO);
            glBindBuffer(GL_ARRAY_BUFFER, VBO);

            // This will copy the data into the currently bound buffer, so in
            // our case, VBO.
            glBufferData(GL_ARRAY_BUFFER, vertices.size(), vertices.data(), usage);
        }

    private:
        GL_ID VBO;
        Container vertices;
        GLenum usage = GL_STATIC_DRAW;
};

class Fragment_Shader : Abstract_Shader
{
    public:
        Fragment_Shader(const std::string &code)
            : Abstract_Shader(glCreateShader(GL_FRAGMENT_SHADER), code)
        {}
};

class Program_Shader
{
    public:
        Program_Shader()
        {
            prog = glCreateProgram();
        }

        void attach_shader(const Abstract_Shader &shader)
        {
            glAttachShader(prog, shader.get_shader_id());
        }

        void use()
        {
            glUseProgram(prog);
        }

        int link()
        {
            int success;
            glLinkProgram(prog);
            glGetProgramiv(prog, GL_LINK_STATUS, &success);
            return success;
        }

        std::string get_link_error()
        {
            char log[512];
            glGetShaderInfoLog(prog, 512, NULL, log);
            return std::string(log);
        }
    private:
        GL_ID prog;
};

namespace Shaders {
@@SHADERS@@
};
